<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>{% block title %}Chronos{% endblock %}</title>
    <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='favicon.ico') }}">
    <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}">
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='vendor/bootstrap.min.css') }}"
    >
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='vendor/fullcalendar.min.css') }}"
    >
    <style>
      body {
        padding-top: 4.5rem;
      }
      .fc-event-title {
        white-space: normal;
      }
      .fc-timegrid-slots table:nth-child(1) tbody:nth-child(2) tr{
        height: 3.5rem;
      }
    </style>
    {% block stylesheets %}{% endblock %}
    <script>
      window.CHRONOS_PAUSE_BACKGROUNDS = [
        {
          daysOfWeek: [1, 2, 3, 4, 5],
          startTime: '10:00:00',
          endTime: '10:15:00',
          display: 'background',
          overlap: false,
          color: '{{ background_block_color }}'
        },
        {
          daysOfWeek: [1, 2, 3, 4, 5],
          startTime: '12:15:00',
          endTime: '13:30:00',
          display: 'background',
          overlap: false,
          color: '{{ background_block_color }}'
        },
        {
          daysOfWeek: [1, 2, 3, 4, 5],
          startTime: '15:30:00',
          endTime: '15:45:00',
          display: 'background',
          overlap: false,
          color: '{{ background_block_color }}'
        }
      ];
      window.CHRONOS_DEFAULT_BACKGROUNDS = {{ default_backgrounds_json|safe }};
      window.CHRONOS_CLOSING_BACKGROUNDS = {{ closing_backgrounds_json|safe }};
      window.CHRONOS_SLOT_STARTS = {{ schedule_slot_starts_json|safe }};

      function chronosSlotDateForDay(dayDate, timeString) {
        const [hours, minutes, seconds] = timeString.split(':').map(function(part) {
          return parseInt(part || '0', 10);
        });
        const candidate = new Date(dayDate.getTime());
        candidate.setHours(hours || 0, minutes || 0, seconds || 0, 0);
        return candidate;
      }

      function chronosSnapEventToSlots(event) {
        if (!event.start) {
          return;
        }
        const slotStarts = Array.isArray(window.CHRONOS_SLOT_STARTS)
          ? window.CHRONOS_SLOT_STARTS
          : [];
        if (!slotStarts.length) {
          return;
        }
        const originalStart = new Date(event.start.getTime());
        const originalEnd = event.end ? new Date(event.end.getTime()) : null;
        const duration = originalEnd ? originalEnd.getTime() - originalStart.getTime() : null;
        const dayAnchor = new Date(originalStart.getTime());
        dayAnchor.setHours(0, 0, 0, 0);

        let bestStart = null;
        let smallestDiff = Number.POSITIVE_INFINITY;
        slotStarts.forEach(function(timeString) {
          if (typeof timeString !== 'string' || !timeString.length) {
            return;
          }
          const candidate = chronosSlotDateForDay(dayAnchor, timeString);
          const diff = Math.abs(originalStart.getTime() - candidate.getTime());
          if (diff < smallestDiff) {
            smallestDiff = diff;
            bestStart = candidate;
          }
        });

        if (!bestStart) {
          return;
        }
        const bestEnd = duration !== null ? new Date(bestStart.getTime() + duration) : null;
        if (bestEnd) {
          event.setDates(bestStart, bestEnd);
        } else {
          event.setStart(bestStart);
        }
      }

      function chronosCloneEvents(events) {
        if (!Array.isArray(events)) {
          return [];
        }
        return events.map(function(event) { return Object.assign({}, event); });
      }

      function chronosPad(number) {
        return String(number).padStart(2, '0');
      }

      function chronosFormatLocalISO(date) {
        if (!(date instanceof Date)) {
          return null;
        }
        return [
          date.getFullYear(),
          '-',
          chronosPad(date.getMonth() + 1),
          '-',
          chronosPad(date.getDate()),
          'T',
          chronosPad(date.getHours()),
          ':',
          chronosPad(date.getMinutes()),
          ':',
          chronosPad(date.getSeconds()),
        ].join('');
      }

      const CHRONOS_COURSE_TYPE_LABELS = {
        CM: 'Cours magistral',
        TD: 'Travaux dirigés',
        TP: 'Travaux pratiques',
        SAE: "Situation d'apprentissage et d'évaluation",
      };

      const CHRONOS_EVENT_DATE_FORMATTER = new Intl.DateTimeFormat('fr-FR', {
        weekday: 'long',
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
      });

      const CHRONOS_EVENT_TIME_FORMATTER = new Intl.DateTimeFormat('fr-FR', {
        hour: '2-digit',
        minute: '2-digit',
      });

      function chronosCapitalize(text) {
        if (typeof text !== 'string' || text.length === 0) {
          return text;
        }
        return text.charAt(0).toUpperCase() + text.slice(1);
      }

      function chronosBuildEventSchedule(start, end) {
        if (!(start instanceof Date)) {
          return '';
        }
        const startDateText = chronosCapitalize(CHRONOS_EVENT_DATE_FORMATTER.format(start));
        const startTimeText = CHRONOS_EVENT_TIME_FORMATTER.format(start);
        if (!(end instanceof Date)) {
          return `${startDateText} à ${startTimeText}`;
        }
        const endDateText = chronosCapitalize(CHRONOS_EVENT_DATE_FORMATTER.format(end));
        const endTimeText = CHRONOS_EVENT_TIME_FORMATTER.format(end);
        if (start.toDateString() === end.toDateString()) {
          return `${startDateText} de ${startTimeText} à ${endTimeText}`;
        }
        return `${startDateText} ${startTimeText} → ${endDateText} ${endTimeText}`;
      }

      function chronosSetField(modal, fieldName, value) {
        const target = modal.querySelector(`[data-chronos-field="${fieldName}"]`);
        if (!target) {
          return;
        }
        const wrappers = modal.querySelectorAll(`[data-chronos-wrapper="${fieldName}"]`);
        const hasValue = value !== null && value !== undefined && String(value).trim().length > 0;
        if (!hasValue) {
          target.textContent = '';
          wrappers.forEach(function(wrapper) {
            wrapper.classList.add('d-none');
          });
          return;
        }
        target.textContent = String(value);
        wrappers.forEach(function(wrapper) {
          wrapper.classList.remove('d-none');
        });
      }

      function chronosDisplayEventSummary(event) {
        const modal = document.getElementById('chronos-event-modal');
        if (!modal) {
          return;
        }
        const props = event.extendedProps || {};
        const title = modal.querySelector('[data-chronos-field="title"]');
        if (title) {
          title.textContent = event.title || props.course || 'Séance planifiée';
        }
        const scheduleField = modal.querySelector('[data-chronos-field="schedule"]');
        if (scheduleField) {
          scheduleField.style.whiteSpace = '';
        }
        let scheduleText = '';
        const segments = Array.isArray(props.segments) ? props.segments : null;
        if (segments && segments.length > 1) {
          const firstSegment = segments[0];
          const firstDateCandidate = firstSegment && firstSegment.start ? new Date(firstSegment.start) : event.start;
          const firstDateIsValid = firstDateCandidate instanceof Date && !Number.isNaN(firstDateCandidate.valueOf());
          const dayText = firstDateIsValid
            ? chronosCapitalize(CHRONOS_EVENT_DATE_FORMATTER.format(firstDateCandidate))
            : '';
          const lines = segments.map(function(segment) {
            const segStart = segment.start ? new Date(segment.start) : null;
            const segEnd = segment.end ? new Date(segment.end) : null;
            if (!segStart || !segEnd) {
              return '';
            }
            if (Number.isNaN(segStart.valueOf()) || Number.isNaN(segEnd.valueOf())) {
              return '';
            }
            const rangeText = `${CHRONOS_EVENT_TIME_FORMATTER.format(segStart)} → ${CHRONOS_EVENT_TIME_FORMATTER.format(segEnd)}`;
            if (segment.room) {
              return `${rangeText} • ${segment.room}`;
            }
            return rangeText;
          }).filter(function(line) { return line.length > 0; });
          if (lines.length > 0) {
            scheduleText = dayText ? `${dayText}\n${lines.join('\n')}` : lines.join('\n');
            if (scheduleField) {
              scheduleField.style.whiteSpace = 'pre-line';
            }
          }
        }
        if (!scheduleText) {
          const schedule = chronosBuildEventSchedule(event.start, event.end);
          scheduleText = schedule;
        }
        chronosSetField(modal, 'schedule', scheduleText);
        chronosSetField(modal, 'course', props.course || '');
        const typeLabel = props.course_type_label || CHRONOS_COURSE_TYPE_LABELS[props.course_type] || '';
        chronosSetField(modal, 'course_type', typeLabel);
        const teacherContact = [props.teacher_email, props.teacher_phone].filter(Boolean).join(' • ');
        let teacherText = props.teacher || '';
        if (teacherContact) {
          teacherText = teacherText ? `${teacherText} (${teacherContact})` : teacherContact;
        }
        chronosSetField(modal, 'teacher', teacherText);
        chronosSetField(modal, 'class_group', props.class_group || '');
        const classGroupLabels = modal.querySelectorAll('[data-chronos-wrapper="class_group"]');
        const classCount = Array.isArray(props.class_groups) ? props.class_groups.length : (props.class_group ? 1 : 0);
        classGroupLabels.forEach(function(node) {
          if (node.tagName === 'DT') {
            node.textContent = classCount > 1 ? 'Classes' : 'Classe';
          }
        });
        const subgroupText = props.subgroup_name || (props.subgroup ? `Groupe ${props.subgroup}` : '');
        chronosSetField(modal, 'subgroup', subgroupText);
        chronosSetField(modal, 'room', props.room || '');
        let computersText = '';
        if (props.requires_computers) {
          const normaliseCount = (value) => {
            const numeric = Number(value);
            return Number.isFinite(numeric) ? numeric : NaN;
          };
          const requiredCount = normaliseCount(props.computers_required);
          const roomCount = normaliseCount(props.room_computers);
          const parts = ['Oui'];
          if (!Number.isNaN(requiredCount) && requiredCount > 0) {
            parts.push(`${requiredCount} poste${requiredCount > 1 ? 's' : ''} requis`);
          }
          if (!Number.isNaN(roomCount) && roomCount >= 0) {
            parts.push(`Salle : ${roomCount}`);
          }
          computersText = parts.join(' — ');
        } else if (props.requires_computers === false) {
          computersText = 'Non';
        }
        chronosSetField(modal, 'computers', computersText);
        const requiredSoftwares = Array.isArray(props.course_softwares) ? props.course_softwares : [];
        const missingSoftwares = Array.isArray(props.missing_softwares) ? props.missing_softwares : [];
        const requiredText = requiredSoftwares.length ? requiredSoftwares.join(', ') : 'Aucun';
        chronosSetField(modal, 'softwares_required', requiredText);
        const missingText = missingSoftwares.length ? missingSoftwares.join(', ') : 'Aucun';
        chronosSetField(modal, 'softwares_missing', missingText);
        const missingWrappers = modal.querySelectorAll('[data-chronos-wrapper="softwares_missing"]');
        missingWrappers.forEach(function(wrapper) {
          if (!wrapper.hasAttribute('data-chronos-field')) {
            wrapper.classList.remove('text-danger');
            return;
          }
          if (missingSoftwares.length) {
            wrapper.classList.add('text-danger');
          } else {
            wrapper.classList.remove('text-danger');
          }
        });
        chronosSetField(modal, 'description', props.course_description || '');
        const bootstrapModal = bootstrap.Modal.getOrCreateInstance(modal);
        bootstrapModal.show();
      }

      async function chronosUpdateSession(event) {
        const props = event.extendedProps || {};
        const segmentIds = Array.isArray(props.segment_ids) && props.segment_ids.length
          ? props.segment_ids
          : [event.id];
        if (segmentIds.length !== 1) {
          throw new Error('Impossible de déplacer un bloc contenant plusieurs séances.');
        }
        if (!event.end) {
          throw new Error('La séance doit avoir une heure de fin définie');
        }
        const startIso = chronosFormatLocalISO(event.start);
        const endIso = chronosFormatLocalISO(event.end);
        if (!startIso || !endIso) {
          throw new Error('Impossible de déterminer les horaires du déplacement');
        }
        const response = await fetch(`/sessions/${segmentIds[0]}/move`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            start: startIso,
            end: endIso,
          }),
        });
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          const message = payload.error || 'Impossible de déplacer la séance';
          throw new Error(message);
        }
        if (payload.event) {
          if (payload.event.title) {
            event.setProp('title', payload.event.title);
          }
          const startDate = new Date(payload.event.start);
          const endDate = new Date(payload.event.end);
          event.setDates(startDate, endDate);
          if (payload.event.extendedProps) {
            Object.keys(payload.event.extendedProps).forEach(function(key) {
              event.setExtendedProp(key, payload.event.extendedProps[key]);
            });
          }
        }
      }

      async function chronosDeleteSession(event) {
        const props = event.extendedProps || {};
        const segmentIds = Array.isArray(props.segment_ids) && props.segment_ids.length
          ? props.segment_ids
          : [event.id];
        for (const segmentId of segmentIds) {
          const response = await fetch(`/sessions/${segmentId}`, { method: 'DELETE' });
          const payload = await response.json().catch(() => ({}));
          if (!response.ok) {
            const message = payload.error || 'Impossible de supprimer la séance';
            throw new Error(message);
          }
        }
      }

      window.createChronosCalendar = function(element, events, extraSources, overrides) {
        extraSources = extraSources || [];
        overrides = overrides || {};
        const config = Object.assign({
          initialView: 'timeGridWeek',
          locale: 'fr',
          slotMinTime: '07:00:00',
          slotMaxTime: '19:00:00',
          slotDuration: '01:00:00',
          snapDuration: '00:15:00',
          firstDay: 1,
          weekends: false,
          allDaySlot: false,
          editable: true,
          eventDurationEditable: false,
          headerToolbar: {
            left: 'prev,next today',
            center: 'title',
            right: 'dayGridMonth,timeGridWeek,timeGridDay'
          },
          events: events || [],
          eventDrop: function(info) {
            const props = info.event.extendedProps || {};
            const segmentIds = Array.isArray(props.segment_ids) ? props.segment_ids : [];
            if (segmentIds.length > 1) {
              info.revert();
              window.alert('Impossible de déplacer un bloc contenant plusieurs séances.');
              return;
            }
            chronosSnapEventToSlots(info.event);
            chronosUpdateSession(info.event).catch(function(error) {
              info.revert();
              window.alert(error.message || error);
            });
          },
          eventClick: function(info) {
            if (info.jsEvent) {
              info.jsEvent.preventDefault();
            }
            chronosDisplayEventSummary(info.event);
          },
          eventDidMount: function(info) {
            if (!info.el || info.el.dataset.chronosContextMenuBound === '1') {
              return;
            }
            info.el.dataset.chronosContextMenuBound = '1';
            info.el.addEventListener('contextmenu', function(event) {
              event.preventDefault();
              const props = info.event.extendedProps || {};
              const segmentIds = Array.isArray(props.segment_ids) ? props.segment_ids : [];
              const confirmationMessage = segmentIds.length > 1
                ? 'Supprimer toutes les séances de ce bloc ?'
                : 'Supprimer cette séance ?';
              if (!window.confirm(confirmationMessage)) {
                return;
              }
              chronosDeleteSession(info.event)
                .then(function() {
                  info.event.remove();
                })
                .catch(function(error) {
                  window.alert(error.message || error);
                });
            });
          },
        }, overrides);

        const calendar = new FullCalendar.Calendar(element, config);

        if (Array.isArray(window.CHRONOS_DEFAULT_BACKGROUNDS) && window.CHRONOS_DEFAULT_BACKGROUNDS.length) {
          calendar.addEventSource(chronosCloneEvents(window.CHRONOS_DEFAULT_BACKGROUNDS));
        }
        if (Array.isArray(window.CHRONOS_CLOSING_BACKGROUNDS) && window.CHRONOS_CLOSING_BACKGROUNDS.length) {
          calendar.addEventSource(chronosCloneEvents(window.CHRONOS_CLOSING_BACKGROUNDS));
        }
        if (Array.isArray(window.CHRONOS_PAUSE_BACKGROUNDS) && window.CHRONOS_PAUSE_BACKGROUNDS.length) {
          calendar.addEventSource(chronosCloneEvents(window.CHRONOS_PAUSE_BACKGROUNDS));
        }
        if (Array.isArray(extraSources)) {
          extraSources.forEach(function(source) {
            if (Array.isArray(source) && source.length) {
              calendar.addEventSource(chronosCloneEvents(source));
            }
          });
        }

        return calendar;
      };
    </script>
    {% block head %}{% endblock %}
  </head>
  <body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
      <div class="container-fluid">
        <a class="navbar-brand" href="{{ url_for('main.dashboard') }}">Chronos</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item"><a class="nav-link" href="{{ url_for('main.dashboard') }}">Tableau de bord</a></li>
            <li class="nav-item"><a class="nav-link" href="{{ url_for('main.teachers_list') }}">Enseignants</a></li>
            <li class="nav-item"><a class="nav-link" href="{{ url_for('main.classes_list') }}">Classes</a></li>
            <li class="nav-item"><a class="nav-link" href="{{ url_for('main.rooms_list') }}">Salles</a></li>
            <li class="nav-item"><a class="nav-link" href="{{ url_for('main.courses_list') }}">Cours</a></li>
            <li class="nav-item"><a class="nav-link" href="{{ url_for('main.configuration') }}">Configuration</a></li>
          </ul>
        </div>
      </div>
    </nav>
    <main class="container-fluid">
      {% with messages = get_flashed_messages(with_categories=True) %}
        {% if messages %}
          <div class="mt-3">
            {% for category, message in messages %}
              <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
                {{ message }}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Fermer"></button>
              </div>
            {% endfor %}
          </div>
        {% endif %}
      {% endwith %}
      {% block content %}{% endblock %}
    </main>
    <div class="modal fade" id="chronos-event-modal" tabindex="-1" aria-labelledby="chronos-event-modal-label" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="chronos-event-modal-label" data-chronos-field="title">Séance planifiée</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fermer"></button>
          </div>
          <div class="modal-body">
            <p class="text-muted mb-3" data-chronos-wrapper="schedule">
              <span data-chronos-field="schedule"></span>
            </p>
            <dl class="row mb-0">
              <dt class="col-sm-4" data-chronos-wrapper="course">Cours</dt>
              <dd class="col-sm-8" data-chronos-wrapper="course" data-chronos-field="course"></dd>
              <dt class="col-sm-4" data-chronos-wrapper="course_type">Type</dt>
              <dd class="col-sm-8" data-chronos-wrapper="course_type" data-chronos-field="course_type"></dd>
              <dt class="col-sm-4" data-chronos-wrapper="teacher">Enseignant</dt>
              <dd class="col-sm-8" data-chronos-wrapper="teacher" data-chronos-field="teacher"></dd>
              <dt class="col-sm-4" data-chronos-wrapper="class_group">Classe</dt>
              <dd class="col-sm-8" data-chronos-wrapper="class_group" data-chronos-field="class_group"></dd>
              <dt class="col-sm-4" data-chronos-wrapper="subgroup">Sous-groupe</dt>
              <dd class="col-sm-8" data-chronos-wrapper="subgroup" data-chronos-field="subgroup"></dd>
              <dt class="col-sm-4" data-chronos-wrapper="room">Salle</dt>
              <dd class="col-sm-8" data-chronos-wrapper="room" data-chronos-field="room"></dd>
              <dt class="col-sm-4" data-chronos-wrapper="softwares_required">Logiciels requis</dt>
              <dd class="col-sm-8" data-chronos-wrapper="softwares_required" data-chronos-field="softwares_required"></dd>
              <dt class="col-sm-4" data-chronos-wrapper="softwares_missing">Logiciels manquants</dt>
              <dd class="col-sm-8" data-chronos-wrapper="softwares_missing" data-chronos-field="softwares_missing"></dd>
              <dt class="col-sm-4" data-chronos-wrapper="computers">Ordinateurs</dt>
              <dd class="col-sm-8" data-chronos-wrapper="computers" data-chronos-field="computers"></dd>
            </dl>
            <div class="mt-3 d-none" data-chronos-wrapper="description">
              <h6 class="fw-semibold">Description</h6>
              <p class="mb-0" data-chronos-field="description"></p>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.11/index.global.min.js"></script>
    {% block scripts %}{% endblock %}
  </body>
</html>
